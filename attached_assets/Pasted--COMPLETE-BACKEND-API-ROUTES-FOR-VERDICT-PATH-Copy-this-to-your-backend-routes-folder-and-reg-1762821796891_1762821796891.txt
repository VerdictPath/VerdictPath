// COMPLETE BACKEND API ROUTES FOR VERDICT PATH
// Copy this to your backend /routes/ folder and register in your main server file

const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { authenticateToken } = require('../middleware/auth');
const db = require('../config/database');

// ============================================================================
// AUTHENTICATION ROUTES
// ============================================================================

// Register Individual Client
router.post('/auth/register-client', async (req, res) => {
  try {
    const {
      firstName,
      lastName,
      email,
      password,
      lawFirmCode,
      avatarType,
      subscriptionTier,
      subscriptionPrice,
      privacyAccepted
    } = req.body;

    // Validation
    if (!firstName || !lastName || !email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    if (!privacyAccepted) {
      return res.status(400).json({
        success: false,
        message: 'You must accept the privacy policy to continue'
      });
    }

    // Email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid email format'
      });
    }

    // Check if email already exists
    const existingUser = await db.query(
      'SELECT id FROM clients WHERE email = $1',
      [email.toLowerCase()]
    );

    if (existingUser.rows.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered'
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Find law firm if code provided
    let lawFirmId = null;
    if (lawFirmCode) {
      const lawFirm = await db.query(
        'SELECT id FROM law_firms WHERE firm_code = $1',
        [lawFirmCode]
      );
      
      if (lawFirm.rows.length > 0) {
        lawFirmId = lawFirm.rows[0].id;
      }
    }

    // Create user
    const result = await db.query(
      `INSERT INTO clients (
        first_name, last_name, email, password_hash, 
        law_firm_id, avatar_type, subscription_tier, 
        subscription_price, privacy_accepted, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
      RETURNING id, first_name, last_name, email, avatar_type, subscription_tier`,
      [
        firstName,
        lastName,
        email.toLowerCase(),
        hashedPassword,
        lawFirmId,
        avatarType || 'captain',
        subscriptionTier || 'free',
        subscriptionPrice || 0,
        privacyAccepted
      ]
    );

    const user = result.rows[0];

    // Initialize coins and streak
    await db.query(
      `INSERT INTO coin_balances (user_id, user_type, balance, lifetime_credits_earned, created_at)
       VALUES ($1, $2, $3, $4, NOW())`,
      [user.id, 'individual', 0, 0]
    );

    await db.query(
      `INSERT INTO login_streaks (user_id, user_type, current_streak, longest_streak, last_login)
       VALUES ($1, $2, $3, $4, NOW())`,
      [user.id, 'individual', 0, 0]
    );

    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, email: user.email, type: 'individual' },
      process.env.JWT_SECRET,
      { expiresIn: '30d' }
    );

    res.status(201).json({
      success: true,
      token,
      user: {
        id: user.id,
        firstName: user.first_name,
        lastName: user.last_name,
        email: user.email,
        avatarType: user.avatar_type,
        subscriptionTier: user.subscription_tier
      }
    });

  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      message: 'Registration failed. Please try again.'
    });
  }
});

// Register Law Firm
router.post('/auth/register-lawfirm', async (req, res) => {
  try {
    const {
      firmName,
      email,
      password,
      subscriptionTier,
      firmSize,
      privacyAccepted
    } = req.body;

    if (!firmName || !email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    if (!privacyAccepted) {
      return res.status(400).json({
        success: false,
        message: 'You must accept the privacy policy to continue'
      });
    }

    // Check if email exists
    const existingFirm = await db.query(
      'SELECT id FROM law_firms WHERE email = $1',
      [email.toLowerCase()]
    );

    if (existingFirm.rows.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered'
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Generate unique firm code
    const firmCode = `LF${Date.now().toString(36).toUpperCase()}`;

    // Create law firm
    const result = await db.query(
      `INSERT INTO law_firms (
        firm_name, email, password_hash, firm_code,
        subscription_tier, firm_size, privacy_accepted, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
      RETURNING id, firm_name, email, firm_code, subscription_tier`,
      [
        firmName,
        email.toLowerCase(),
        hashedPassword,
        firmCode,
        subscriptionTier || 'free',
        firmSize,
        privacyAccepted
      ]
    );

    const lawFirm = result.rows[0];

    // Generate JWT token
    const token = jwt.sign(
      { id: lawFirm.id, email: lawFirm.email, type: 'lawfirm' },
      process.env.JWT_SECRET,
      { expiresIn: '30d' }
    );

    res.status(201).json({
      success: true,
      token,
      lawFirm: {
        id: lawFirm.id,
        firmName: lawFirm.firm_name,
        email: lawFirm.email,
        firmCode: lawFirm.firm_code,
        subscriptionTier: lawFirm.subscription_tier
      }
    });

  } catch (error) {
    console.error('Law firm registration error:', error);
    res.status(500).json({
      success: false,
      message: 'Registration failed. Please try again.'
    });
  }
});

// Register Medical Provider
router.post('/auth/register-medicalprovider', async (req, res) => {
  try {
    const {
      providerName,
      email,
      password,
      subscriptionTier,
      providerSize,
      privacyAccepted
    } = req.body;

    if (!providerName || !email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    if (!privacyAccepted) {
      return res.status(400).json({
        success: false,
        message: 'You must accept the privacy policy to continue'
      });
    }

    // Check if email exists
    const existingProvider = await db.query(
      'SELECT id FROM medical_providers WHERE email = $1',
      [email.toLowerCase()]
    );

    if (existingProvider.rows.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Email already registered'
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Generate unique provider code
    const providerCode = `MP${Date.now().toString(36).toUpperCase()}`;

    // Create medical provider
    const result = await db.query(
      `INSERT INTO medical_providers (
        provider_name, email, password_hash, provider_code,
        subscription_tier, provider_size, privacy_accepted, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
      RETURNING id, provider_name, email, provider_code, subscription_tier`,
      [
        providerName,
        email.toLowerCase(),
        hashedPassword,
        providerCode,
        subscriptionTier || 'free',
        providerSize,
        privacyAccepted
      ]
    );

    const provider = result.rows[0];

    // Generate JWT token
    const token = jwt.sign(
      { id: provider.id, email: provider.email, type: 'medical_provider' },
      process.env.JWT_SECRET,
      { expiresIn: '30d' }
    );

    res.status(201).json({
      success: true,
      token,
      medicalProvider: {
        id: provider.id,
        providerName: provider.provider_name,
        email: provider.email,
        providerCode: provider.provider_code,
        subscriptionTier: provider.subscription_tier
      }
    });

  } catch (error) {
    console.error('Medical provider registration error:', error);
    res.status(500).json({
      success: false,
      message: 'Registration failed. Please try again.'
    });
  }
});

// Login
router.post('/auth/login', async (req, res) => {
  try {
    const { email, password, userType } = req.body;

    if (!email || !password || !userType) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }

    let query, tableName, type;

    // Determine which table to query
    if (userType === 'individual') {
      tableName = 'clients';
      type = 'individual';
      query = 'SELECT * FROM clients WHERE email = $1';
    } else if (userType === 'lawfirm') {
      tableName = 'law_firms';
      type = 'lawfirm';
      query = 'SELECT * FROM law_firms WHERE email = $1';
    } else if (userType === 'medical_provider') {
      tableName = 'medical_providers';
      type = 'medical_provider';
      query = 'SELECT * FROM medical_providers WHERE email = $1';
    } else {
      return res.status(400).json({
        success: false,
        message: 'Invalid user type'
      });
    }

    // Find user
    const result = await db.query(query, [email.toLowerCase()]);

    if (result.rows.length === 0) {
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
    }

    const user = result.rows[0];

    // Verify password
    const validPassword = await bcrypt.compare(password, user.password_hash);

    if (!validPassword) {
      return res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
    }

    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, email: user.email, type },
      process.env.JWT_SECRET,
      { expiresIn: '30d' }
    );

    // Format response based on user type
    let userData = {
      id: user.id,
      email: user.email
    };

    if (type === 'individual') {
      userData.firstName = user.first_name;
      userData.lastName = user.last_name;
      userData.avatarType = user.avatar_type;
      userData.subscriptionTier = user.subscription_tier;
    } else if (type === 'lawfirm') {
      userData.firmName = user.firm_name;
      userData.firmCode = user.firm_code;
      userData.subscriptionTier = user.subscription_tier;
    } else if (type === 'medical_provider') {
      userData.providerName = user.provider_name;
      userData.providerCode = user.provider_code;
      userData.subscriptionTier = user.subscription_tier;
    }

    res.json({
      success: true,
      token,
      user: userData
    });

  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Login failed. Please try again.'
    });
  }
});

// ============================================================================
// COINS ROUTES
// ============================================================================

// Get coin balance
router.get('/coins/balance', authenticateToken, async (req, res) => {
  try {
    const result = await db.query(
      'SELECT balance, lifetime_credits_earned FROM coin_balances WHERE user_id = $1 AND user_type = $2',
      [req.user.id, req.user.type]
    );

    if (result.rows.length === 0) {
      // Initialize if doesn't exist
      await db.query(
        'INSERT INTO coin_balances (user_id, user_type, balance, lifetime_credits_earned) VALUES ($1, $2, $3, $4)',
        [req.user.id, req.user.type, 0, 0]
      );
      
      return res.json({
        success: true,
        balance: 0,
        lifetimeCreditsEarned: 0
      });
    }

    res.json({
      success: true,
      balance: result.rows[0].balance,
      lifetimeCreditsEarned: result.rows[0].lifetime_credits_earned
    });

  } catch (error) {
    console.error('Get balance error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get balance'
    });
  }
});

// Claim daily bonus
router.post('/coins/claim-daily', authenticateToken, async (req, res) => {
  try {
    // Get current streak
    const streakResult = await db.query(
      'SELECT * FROM login_streaks WHERE user_id = $1 AND user_type = $2',
      [req.user.id, req.user.type]
    );

    let currentStreak = 0;
    let lastLogin = null;

    if (streakResult.rows.length > 0) {
      currentStreak = streakResult.rows[0].current_streak;
      lastLogin = streakResult.rows[0].last_login;
    }

    // Check if already claimed today
    if (lastLogin) {
      const lastLoginDate = new Date(lastLogin);
      const today = new Date();
      lastLoginDate.setHours(0, 0, 0, 0);
      today.setHours(0, 0, 0, 0);

      if (lastLoginDate.getTime() === today.getTime()) {
        return res.status(400).json({
          success: false,
          message: 'You have already claimed your daily reward today'
        });
      }
    }

    // Calculate new streak
    let newStreak = 1;
    if (lastLogin) {
      const lastLoginDate = new Date(lastLogin);
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      yesterday.setHours(0, 0, 0, 0);
      lastLoginDate.setHours(0, 0, 0, 0);

      if (lastLoginDate.getTime() === yesterday.getTime()) {
        newStreak = currentStreak + 1;
      }
    }

    // Calculate bonus (50 coins base + 10 per streak day, max 200)
    const bonusCoins = Math.min(50 + (newStreak * 10), 200);

    // Update streak
    if (streakResult.rows.length === 0) {
      await db.query(
        'INSERT INTO login_streaks (user_id, user_type, current_streak, longest_streak, last_login) VALUES ($1, $2, $3, $4, NOW())',
        [req.user.id, req.user.type, newStreak, newStreak]
      );
    } else {
      await db.query(
        `UPDATE login_streaks 
         SET current_streak = $1, 
             longest_streak = GREATEST(longest_streak, $1),
             last_login = NOW()
         WHERE user_id = $2 AND user_type = $3`,
        [newStreak, req.user.id, req.user.type]
      );
    }

    // Add coins
    await db.query(
      'UPDATE coin_balances SET balance = balance + $1 WHERE user_id = $2 AND user_type = $3',
      [bonusCoins, req.user.id, req.user.type]
    );

    // Log transaction
    await db.query(
      `INSERT INTO coin_transactions (user_id, user_type, amount, transaction_type, description, created_at)
       VALUES ($1, $2, $3, $4, $5, NOW())`,
      [req.user.id, req.user.type, bonusCoins, 'daily_bonus', `Daily login bonus (${newStreak} day streak)`]
    );

    // Get new balance
    const balanceResult = await db.query(
      'SELECT balance FROM coin_balances WHERE user_id = $1 AND user_type = $2',
      [req.user.id, req.user.type]
    );

    res.json({
      success: true,
      message: `üéâ ${bonusCoins} coins earned! Current streak: ${newStreak} days`,
      coinsEarned: bonusCoins,
      totalCoins: balanceResult.rows[0].balance,
      newStreak
    });

  } catch (error) {
    console.error('Claim daily bonus error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to claim daily bonus'
    });
  }
});

// Convert coins to credits
router.post('/coins/convert', authenticateToken, async (req, res) => {
  try {
    const { coinsToConvert } = req.body;

    if (!coinsToConvert || coinsToConvert < 5000) {
      return res.status(400).json({
        success: false,
        message: 'Minimum 5,000 coins required for conversion'
      });
    }

    // Get current balance and lifetime credits
    const balanceResult = await db.query(
      'SELECT balance, lifetime_credits_earned FROM coin_balances WHERE user_id = $1 AND user_type = $2',
      [req.user.id, req.user.type]
    );

    if (balanceResult.rows.length === 0 || balanceResult.rows[0].balance < coinsToConvert) {
      return res.status(400).json({
        success: false,
        message: 'Insufficient coin balance'
      });
    }

    const currentBalance = balanceResult.rows[0].balance;
    const lifetimeCreditsEarned = balanceResult.rows[0].lifetime_credits_earned || 0;

    // Check $5 lifetime cap
    if (lifetimeCreditsEarned >= 5) {
      return res.status(400).json({
        success: false,
        message: 'üí∞ You\'ve reached your $5 lifetime conversion cap!'
      });
    }

    // Calculate credits (5000 coins = $1)
    const creditsToAdd = Math.floor(coinsToConvert / 5000);
    const newLifetimeTotal = lifetimeCreditsEarned + creditsToAdd;

    // Check if this conversion would exceed cap
    if (newLifetimeTotal > 5) {
      const remainingAllowed = 5 - lifetimeCreditsEarned;
      return res.status(400).json({
        success: false,
        message: `‚ö†Ô∏è This conversion would exceed your lifetime cap. You can only convert $${remainingAllowed} more.`
      });
    }

    // Deduct coins
    await db.query(
      'UPDATE coin_balances SET balance = balance - $1, lifetime_credits_earned = $2 WHERE user_id = $3 AND user_type = $4',
      [coinsToConvert, newLifetimeTotal, req.user.id, req.user.type]
    );

    // Log transaction
    await db.query(
      `INSERT INTO coin_transactions (user_id, user_type, amount, transaction_type, description, created_at)
       VALUES ($1, $2, $3, $4, $5, NOW())`,
      [req.user.id, req.user.type, -coinsToConvert, 'conversion', `Converted to $${creditsToAdd} credits`]
    );

    const remainingLifetimeCredits = 5 - newLifetimeTotal;

    res.json({
      success: true,
      message: 'Coins converted successfully!',
      coinsSpent: coinsToConvert,
      coinsConverted: coinsToConvert,
      creditAmount: creditsToAdd,
      totalCoins: currentBalance - coinsToConvert,
      lifetimeCreditsEarned: newLifetimeTotal,
      remainingLifetimeCredits
    });

  } catch (error) {
    console.error('Convert coins error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to convert coins'
    });
  }
});

module.exports = router;