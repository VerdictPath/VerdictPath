# VerdictPath - Law Firm Client Portal System
# Vibe Code for Replit Implementation

## Project Structure
```
verdictpath/
├── models/
│   ├── User.js
│   ├── LawFirm.js
│   ├── Client.js
│   ├── MedicalRecord.js
│   ├── MedicalBilling.js
│   ├── Evidence.js
│   └── LitigationStage.js
├── routes/
│   ├── auth.js
│   ├── lawfirm.js
│   └── client.js
├── controllers/
│   ├── authController.js
│   ├── lawfirmController.js
│   └── clientController.js
├── middleware/
│   ├── auth.js
│   └── lawfirmAuth.js
├── views/
│   ├── lawfirm-dashboard.ejs
│   ├── client-details.ejs
│   └── litigation-stages.ejs
└── server.js
```

## Database Schema Design

### User Model
```javascript
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    trim: true
  },
  lastName: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true
  },
  userType: {
    type: String,
    enum: ['client', 'lawfirm'],
    required: true
  },
  lawFirmCode: {
    type: String,
    default: null,
    index: true
  },
  connectedLawFirm: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'LawFirm',
    default: null
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Virtual for full name display (Last, First)
userSchema.virtual('displayName').get(function() {
  return `${this.lastName}, ${this.firstName}`;
});

module.exports = mongoose.model('User', userSchema);
```

### Law Firm Model
```javascript
const lawFirmSchema = new mongoose.Schema({
  firmName: {
    type: String,
    required: true,
    trim: true
  },
  firmCode: {
    type: String,
    required: true,
    unique: true,
    uppercase: true,
    index: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true
  },
  registeredClients: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }],
  barNumber: String,
  phoneNumber: String,
  address: {
    street: String,
    city: String,
    state: String,
    zipCode: String
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('LawFirm', lawFirmSchema);
```

### Medical Record Model
```javascript
const medicalRecordSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  recordType: {
    type: String,
    enum: ['visit_summary', 'lab_results', 'imaging', 'prescription', 'diagnosis', 'treatment_plan', 'other'],
    required: true
  },
  facilityName: String,
  providerName: String,
  dateOfService: Date,
  description: String,
  documentUrl: String, // S3 or cloud storage URL
  fileName: String,
  fileSize: Number,
  mimeType: String,
  uploadedAt: {
    type: Date,
    default: Date.now
  },
  accessibleByLawFirm: {
    type: Boolean,
    default: true
  }
});

module.exports = mongoose.model('MedicalRecord', medicalRecordSchema);
```

### Medical Billing Model
```javascript
const medicalBillingSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  billingType: {
    type: String,
    enum: ['invoice', 'statement', 'insurance_eob', 'payment_receipt', 'itemized_bill'],
    required: true
  },
  facilityName: String,
  billNumber: String,
  dateOfService: Date,
  billDate: Date,
  dueDate: Date,
  totalAmount: {
    type: Number,
    required: true
  },
  amountPaid: {
    type: Number,
    default: 0
  },
  amountDue: {
    type: Number,
    required: true
  },
  insuranceClaimNumber: String,
  procedureCodes: [String], // CPT codes
  diagnosisCodes: [String], // ICD-10 codes
  description: String,
  documentUrl: String,
  fileName: String,
  fileSize: Number,
  mimeType: String,
  uploadedAt: {
    type: Date,
    default: Date.now
  },
  accessibleByLawFirm: {
    type: Boolean,
    default: true
  }
});

module.exports = mongoose.model('MedicalBilling', medicalBillingSchema);
```

### Evidence Document Model
```javascript
const evidenceSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  evidenceType: {
    type: String,
    enum: ['photo', 'video', 'audio', 'document', 'correspondence', 'witness_statement', 'police_report', 'insurance_document', 'other'],
    required: true
  },
  title: {
    type: String,
    required: true
  },
  description: String,
  dateOfIncident: Date,
  location: String,
  tags: [String],
  documentUrl: String,
  fileName: String,
  fileSize: Number,
  mimeType: String,
  uploadedAt: {
    type: Date,
    default: Date.now
  },
  accessibleByLawFirm: {
    type: Boolean,
    default: true
  }
});

module.exports = mongoose.model('Evidence', evidenceSchema);
```

### Litigation Stage Model
```javascript
const litigationStageSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  lawFirmId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'LawFirm',
    required: true
  },
  caseNumber: String,
  currentStage: {
    type: String,
    enum: [
      'initial_consultation',
      'client_intake',
      'investigation',
      'demand_letter',
      'negotiation',
      'pre_litigation',
      'complaint_filed',
      'discovery',
      'mediation',
      'trial_preparation',
      'trial',
      'settlement',
      'appeal',
      'closed'
    ],
    default: 'initial_consultation',
    required: true
  },
  stageHistory: [{
    stage: String,
    completedDate: Date,
    completedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'LawFirm'
    },
    notes: String
  }],
  nextStepDueDate: Date,
  nextStepDescription: String,
  caseValue: Number,
  settlementAmount: Number,
  status: {
    type: String,
    enum: ['active', 'pending', 'settled', 'closed'],
    default: 'active'
  },
  notes: String,
  lastUpdated: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('LitigationStage', litigationStageSchema);
```

## Backend Implementation

### Authentication Middleware
```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');

exports.authenticateToken = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '') || req.cookies.token;
  
  if (!token) {
    return res.status(401).json({ message: 'Access denied. No token provided.' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(403).json({ message: 'Invalid token.' });
  }
};

exports.isLawFirm = (req, res, next) => {
  if (req.user.userType !== 'lawfirm') {
    return res.status(403).json({ message: 'Access denied. Law firm account required.' });
  }
  next();
};

exports.isClient = (req, res, next) => {
  if (req.user.userType !== 'client') {
    return res.status(403).json({ message: 'Access denied. Client account required.' });
  }
  next();
};
```

### Law Firm Controller
```javascript
// controllers/lawfirmController.js
const User = require('../models/User');
const LawFirm = require('../models/LawFirm');
const MedicalRecord = require('../models/MedicalRecord');
const MedicalBilling = require('../models/MedicalBilling');
const Evidence = require('../models/Evidence');
const LitigationStage = require('../models/LitigationStage');

// Get Law Firm Dashboard with all registered clients
exports.getDashboard = async (req, res) => {
  try {
    const lawFirm = await LawFirm.findById(req.user.id)
      .populate({
        path: 'registeredClients',
        select: 'firstName lastName email createdAt',
        options: { sort: { lastName: 1, firstName: 1 } } // Sort by last name, then first name
      });
    
    if (!lawFirm) {
      return res.status(404).json({ message: 'Law firm not found' });
    }
    
    // Format clients for display
    const clients = lawFirm.registeredClients.map(client => ({
      id: client._id,
      displayName: `${client.lastName}, ${client.firstName}`,
      email: client.email,
      registeredDate: client.createdAt
    }));
    
    res.json({
      firmName: lawFirm.firmName,
      firmCode: lawFirm.firmCode,
      totalClients: clients.length,
      clients: clients
    });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching dashboard', error: error.message });
  }
};

// Get all client details including documents and litigation stage
exports.getClientDetails = async (req, res) => {
  try {
    const { clientId } = req.params;
    const lawFirm = await LawFirm.findById(req.user.id);
    
    // Verify this client is registered with this law firm
    if (!lawFirm.registeredClients.includes(clientId)) {
      return res.status(403).json({ message: 'Access denied. Client not registered with your firm.' });
    }
    
    // Get client info
    const client = await User.findById(clientId);
    if (!client) {
      return res.status(404).json({ message: 'Client not found' });
    }
    
    // Get medical records
    const medicalRecords = await MedicalRecord.find({ 
      userId: clientId,
      accessibleByLawFirm: true 
    }).sort({ dateOfService: -1 });
    
    // Get medical billing
    const medicalBilling = await MedicalBilling.find({ 
      userId: clientId,
      accessibleByLawFirm: true 
    }).sort({ billDate: -1 });
    
    // Get evidence documents
    const evidenceDocuments = await Evidence.find({ 
      userId: clientId,
      accessibleByLawFirm: true 
    }).sort({ uploadedAt: -1 });
    
    // Get litigation stage
    const litigationStage = await LitigationStage.findOne({ 
      userId: clientId,
      lawFirmId: req.user.id 
    });
    
    res.json({
      client: {
        id: client._id,
        firstName: client.firstName,
        lastName: client.lastName,
        displayName: `${client.lastName}, ${client.firstName}`,
        email: client.email
      },
      medicalRecords: {
        total: medicalRecords.length,
        records: medicalRecords
      },
      medicalBilling: {
        total: medicalBilling.length,
        totalAmountBilled: medicalBilling.reduce((sum, bill) => sum + bill.totalAmount, 0),
        totalAmountDue: medicalBilling.reduce((sum, bill) => sum + bill.amountDue, 0),
        bills: medicalBilling
      },
      evidenceDocuments: {
        total: evidenceDocuments.length,
        documents: evidenceDocuments
      },
      litigationStage: litigationStage || null
    });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching client details', error: error.message });
  }
};

// Update litigation stage for a client
exports.updateLitigationStage = async (req, res) => {
  try {
    const { clientId } = req.params;
    const { newStage, notes, nextStepDueDate, nextStepDescription, caseValue, settlementAmount } = req.body;
    
    const lawFirm = await LawFirm.findById(req.user.id);
    
    // Verify this client is registered with this law firm
    if (!lawFirm.registeredClients.includes(clientId)) {
      return res.status(403).json({ message: 'Access denied. Client not registered with your firm.' });
    }
    
    // Find or create litigation stage
    let litigationStage = await LitigationStage.findOne({ 
      userId: clientId,
      lawFirmId: req.user.id 
    });
    
    if (!litigationStage) {
      litigationStage = new LitigationStage({
        userId: clientId,
        lawFirmId: req.user.id,
        currentStage: newStage || 'initial_consultation',
        stageHistory: []
      });
    }
    
    // Add previous stage to history if stage is changing
    if (newStage && newStage !== litigationStage.currentStage) {
      litigationStage.stageHistory.push({
        stage: litigationStage.currentStage,
        completedDate: new Date(),
        completedBy: req.user.id,
        notes: notes || ''
      });
      litigationStage.currentStage = newStage;
    }
    
    // Update other fields
    if (notes) litigationStage.notes = notes;
    if (nextStepDueDate) litigationStage.nextStepDueDate = nextStepDueDate;
    if (nextStepDescription) litigationStage.nextStepDescription = nextStepDescription;
    if (caseValue !== undefined) litigationStage.caseValue = caseValue;
    if (settlementAmount !== undefined) litigationStage.settlementAmount = settlementAmount;
    
    litigationStage.lastUpdated = new Date();
    
    await litigationStage.save();
    
    res.json({
      message: 'Litigation stage updated successfully',
      litigationStage
    });
  } catch (error) {
    res.status(500).json({ message: 'Error updating litigation stage', error: error.message });
  }
};

// Complete a specific litigation stage
exports.completeStage = async (req, res) => {
  try {
    const { clientId } = req.params;
    const { completionNotes, nextStage } = req.body;
    
    const lawFirm = await LawFirm.findById(req.user.id);
    
    // Verify this client is registered with this law firm
    if (!lawFirm.registeredClients.includes(clientId)) {
      return res.status(403).json({ message: 'Access denied. Client not registered with your firm.' });
    }
    
    const litigationStage = await LitigationStage.findOne({ 
      userId: clientId,
      lawFirmId: req.user.id 
    });
    
    if (!litigationStage) {
      return res.status(404).json({ message: 'Litigation stage not found for this client' });
    }
    
    // Mark current stage as complete
    litigationStage.stageHistory.push({
      stage: litigationStage.currentStage,
      completedDate: new Date(),
      completedBy: req.user.id,
      notes: completionNotes || `Completed ${litigationStage.currentStage} stage`
    });
    
    // Move to next stage if provided
    if (nextStage) {
      litigationStage.currentStage = nextStage;
    }
    
    litigationStage.lastUpdated = new Date();
    await litigationStage.save();
    
    res.json({
      message: 'Stage completed successfully',
      litigationStage
    });
  } catch (error) {
    res.status(500).json({ message: 'Error completing stage', error: error.message });
  }
};
```

### Client Controller
```javascript
// controllers/clientController.js
const User = require('../models/User');
const LawFirm = require('../models/LawFirm');

// Connect client to law firm using firm code
exports.connectToLawFirm = async (req, res) => {
  try {
    const { firmCode } = req.body;
    const userId = req.user.id;
    
    // Find law firm by code
    const lawFirm = await LawFirm.findOne({ firmCode: firmCode.toUpperCase() });
    
    if (!lawFirm) {
      return res.status(404).json({ message: 'Law firm not found. Please check the firm code.' });
    }
    
    // Update user with law firm connection
    const user = await User.findById(userId);
    user.lawFirmCode = firmCode.toUpperCase();
    user.connectedLawFirm = lawFirm._id;
    await user.save();
    
    // Add client to law firm's registered clients
    if (!lawFirm.registeredClients.includes(userId)) {
      lawFirm.registeredClients.push(userId);
      await lawFirm.save();
    }
    
    res.json({
      message: 'Successfully connected to law firm',
      lawFirm: {
        name: lawFirm.firmName,
        code: lawFirm.firmCode
      }
    });
  } catch (error) {
    res.status(500).json({ message: 'Error connecting to law firm', error: error.message });
  }
};
```

## API Routes

### Law Firm Routes
```javascript
// routes/lawfirm.js
const express = require('express');
const router = express.Router();
const { authenticateToken, isLawFirm } = require('../middleware/auth');
const lawfirmController = require('../controllers/lawfirmController');

// All routes require authentication and law firm account
router.use(authenticateToken);
router.use(isLawFirm);

// Get law firm dashboard with all clients
router.get('/dashboard', lawfirmController.getDashboard);

// Get specific client details with all documents
router.get('/client/:clientId', lawfirmController.getClientDetails);

// Update litigation stage for a client
router.put('/client/:clientId/litigation-stage', lawfirmController.updateLitigationStage);

// Complete a specific stage in litigation
router.post('/client/:clientId/complete-stage', lawfirmController.completeStage);

module.exports = router;
```

### Client Routes
```javascript
// routes/client.js
const express = require('express');
const router = express.Router();
const { authenticateToken, isClient } = require('../middleware/auth');
const clientController = require('../controllers/clientController');

// All routes require authentication and client account
router.use(authenticateToken);
router.use(isClient);

// Connect client to law firm using firm code
router.post('/connect-lawfirm', clientController.connectToLawFirm);

module.exports = router;
```

## Frontend Implementation

### Law Firm Dashboard View (React/Next.js)
```javascript
// pages/lawfirm/dashboard.jsx
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import axios from 'axios';

const LawFirmDashboard = () => {
  const [clients, setClients] = useState([]);
  const [firmInfo, setFirmInfo] = useState({});
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    try {
      const response = await axios.get('/api/lawfirm/dashboard', {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      setClients(response.data.clients);
      setFirmInfo({
        name: response.data.firmName,
        code: response.data.firmCode,
        totalClients: response.data.totalClients
      });
      setLoading(false);
    } catch (error) {
      console.error('Error fetching dashboard:', error);
      setLoading(false);
    }
  };

  const filteredClients = clients.filter(client =>
    client.displayName.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const handleClientClick = (clientId) => {
    router.push(`/lawfirm/client/${clientId}`);
  };

  if (loading) return <div className="loading">Loading dashboard...</div>;

  return (
    <div className="lawfirm-dashboard">
      <header className="dashboard-header">
        <h1>{firmInfo.name}</h1>
        <p className="firm-code">Firm Code: <strong>{firmInfo.code}</strong></p>
        <p className="client-count">Total Registered Clients: {firmInfo.totalClients}</p>
      </header>

      <div className="search-section">
        <input
          type="text"
          placeholder="Search clients by name..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="search-input"
        />
      </div>

      <div className="clients-list">
        <h2>Registered Clients</h2>
        <div className="clients-grid">
          {filteredClients.map(client => (
            <div 
              key={client.id} 
              className="client-card"
              onClick={() => handleClientClick(client.id)}
            >
              <h3>{client.displayName}</h3>
              <p className="client-email">{client.email}</p>
              <p className="registered-date">
                Registered: {new Date(client.registeredDate).toLocaleDateString()}
              </p>
            </div>
          ))}
        </div>
      </div>

      <style jsx>{`
        .lawfirm-dashboard {
          padding: 2rem;
          max-width: 1400px;
          margin: 0 auto;
        }
        .dashboard-header {
          background: linear-gradient(135deg, #1E3A5F 0%, #0D1B2A 100%);
          color: white;
          padding: 2rem;
          border-radius: 12px;
          margin-bottom: 2rem;
        }
        .firm-code {
          margin: 0.5rem 0;
          font-size: 1.1rem;
        }
        .search-section {
          margin-bottom: 2rem;
        }
        .search-input {
          width: 100%;
          max-width: 500px;
          padding: 0.75rem 1rem;
          border: 2px solid #ddd;
          border-radius: 8px;
          font-size: 1rem;
        }
        .clients-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
          gap: 1.5rem;
          margin-top: 1rem;
        }
        .client-card {
          background: white;
          border: 2px solid #e0e0e0;
          border-radius: 12px;
          padding: 1.5rem;
          cursor: pointer;
          transition: all 0.3s ease;
        }
        .client-card:hover {
          border-color: #DAA520;
          box-shadow: 0 4px 12px rgba(218, 165, 32, 0.2);
          transform: translateY(-2px);
        }
        .client-card h3 {
          color: #1E3A5F;
          margin: 0 0 0.5rem 0;
          font-size: 1.3rem;
        }
        .client-email {
          color: #666;
          margin: 0.5rem 0;
        }
        .registered-date {
          color: #999;
          font-size: 0.9rem;
          margin-top: 0.5rem;
        }
      `}</style>
    </div>
  );
};

export default LawFirmDashboard;
```

### Client Details View
```javascript
// pages/lawfirm/client/[clientId].jsx
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import axios from 'axios';

const ClientDetailsPage = () => {
  const router = useRouter();
  const { clientId } = router.query;
  
  const [clientData, setClientData] = useState(null);
  const [activeTab, setActiveTab] = useState('medical-records');
  const [loading, setLoading] = useState(true);
  const [updatingStage, setUpdatingStage] = useState(false);
  
  const [stageUpdate, setStageUpdate] = useState({
    newStage: '',
    notes: '',
    nextStepDescription: '',
    nextStepDueDate: ''
  });

  useEffect(() => {
    if (clientId) {
      fetchClientDetails();
    }
  }, [clientId]);

  const fetchClientDetails = async () => {
    try {
      const response = await axios.get(`/api/lawfirm/client/${clientId}`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        }
      });
      setClientData(response.data);
      if (response.data.litigationStage) {
        setStageUpdate({
          newStage: response.data.litigationStage.currentStage,
          notes: response.data.litigationStage.notes || '',
          nextStepDescription: response.data.litigationStage.nextStepDescription || '',
          nextStepDueDate: response.data.litigationStage.nextStepDueDate || ''
        });
      }
      setLoading(false);
    } catch (error) {
      console.error('Error fetching client details:', error);
      setLoading(false);
    }
  };

  const handleStageUpdate = async () => {
    setUpdatingStage(true);
    try {
      await axios.put(
        `/api/lawfirm/client/${clientId}/litigation-stage`,
        stageUpdate,
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        }
      );
      alert('Litigation stage updated successfully!');
      fetchClientDetails();
    } catch (error) {
      console.error('Error updating stage:', error);
      alert('Failed to update litigation stage');
    }
    setUpdatingStage(false);
  };

  const handleCompleteStage = async () => {
    const confirmComplete = window.confirm('Are you sure you want to mark this stage as complete?');
    if (!confirmComplete) return;

    try {
      await axios.post(
        `/api/lawfirm/client/${clientId}/complete-stage`,
        {
          completionNotes: stageUpdate.notes,
          nextStage: stageUpdate.newStage
        },
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        }
      );
      alert('Stage completed successfully!');
      fetchClientDetails();
    } catch (error) {
      console.error('Error completing stage:', error);
      alert('Failed to complete stage');
    }
  };

  const litigationStages = [
    'initial_consultation',
    'client_intake',
    'investigation',
    'demand_letter',
    'negotiation',
    'pre_litigation',
    'complaint_filed',
    'discovery',
    'mediation',
    'trial_preparation',
    'trial',
    'settlement',
    'appeal',
    'closed'
  ];

  const formatStageName = (stage) => {
    return stage.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  };

  if (loading) return <div className="loading">Loading client details...</div>;
  if (!clientData) return <div className="error">Client not found</div>;

  return (
    <div className="client-details-page">
      <header className="client-header">
        <button onClick={() => router.back()} className="back-button">← Back to Dashboard</button>
        <h1>{clientData.client.displayName}</h1>
        <p className="client-email">{clientData.client.email}</p>
      </header>

      <div className="tabs">
        <button 
          className={activeTab === 'medical-records' ? 'active' : ''}
          onClick={() => setActiveTab('medical-records')}
        >
          Medical Records ({clientData.medicalRecords.total})
        </button>
        <button 
          className={activeTab === 'medical-billing' ? 'active' : ''}
          onClick={() => setActiveTab('medical-billing')}
        >
          Medical Billing ({clientData.medicalBilling.total})
        </button>
        <button 
          className={activeTab === 'evidence' ? 'active' : ''}
          onClick={() => setActiveTab('evidence')}
        >
          Evidence Documents ({clientData.evidenceDocuments.total})
        </button>
        <button 
          className={activeTab === 'litigation' ? 'active' : ''}
          onClick={() => setActiveTab('litigation')}
        >
          Litigation Stage
        </button>
      </div>

      <div className="tab-content">
        {/* Medical Records Tab */}
        {activeTab === 'medical-records' && (
          <div className="medical-records-section">
            <h2>Medical Records</h2>
            {clientData.medicalRecords.records.length === 0 ? (
              <p className="no-data">No medical records available</p>
            ) : (
              <div className="documents-list">
                {clientData.medicalRecords.records.map(record => (
                  <div key={record._id} className="document-card">
                    <div className="document-header">
                      <h3>{formatStageName(record.recordType)}</h3>
                      <span className="document-date">
                        {new Date(record.dateOfService).toLocaleDateString()}
                      </span>
                    </div>
                    <p><strong>Facility:</strong> {record.facilityName || 'N/A'}</p>
                    <p><strong>Provider:</strong> {record.providerName || 'N/A'}</p>
                    <p><strong>Description:</strong> {record.description || 'No description provided'}</p>
                    {record.documentUrl && (
                      <a href={record.documentUrl} target="_blank" rel="noopener noreferrer" className="view-document-btn">
                        View Document
                      </a>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Medical Billing Tab */}
        {activeTab === 'medical-billing' && (
          <div className="medical-billing-section">
            <h2>Medical Billing</h2>
            <div className="billing-summary">
              <div className="summary-card">
                <h3>Total Billed</h3>
                <p className="amount">${clientData.medicalBilling.totalAmountBilled.toFixed(2)}</p>
              </div>
              <div className="summary-card">
                <h3>Total Due</h3>
                <p className="amount due">${clientData.medicalBilling.totalAmountDue.toFixed(2)}</p>
              </div>
            </div>
            {clientData.medicalBilling.bills.length === 0 ? (
              <p className="no-data">No billing records available</p>
            ) : (
              <div className="documents-list">
                {clientData.medicalBilling.bills.map(bill => (
                  <div key={bill._id} className="document-card">
                    <div className="document-header">
                      <h3>{formatStageName(bill.billingType)}</h3>
                      <span className="document-date">
                        {new Date(bill.billDate).toLocaleDateString()}
                      </span>
                    </div>
                    <p><strong>Facility:</strong> {bill.facilityName || 'N/A'}</p>
                    <p><strong>Bill Number:</strong> {bill.billNumber || 'N/A'}</p>
                    <div className="billing-amounts">
                      <p><strong>Total Amount:</strong> ${bill.totalAmount.toFixed(2)}</p>
                      <p><strong>Amount Paid:</strong> ${bill.amountPaid.toFixed(2)}</p>
                      <p><strong>Amount Due:</strong> <span className="due-amount">${bill.amountDue.toFixed(2)}</span></p>
                    </div>
                    {bill.procedureCodes && bill.procedureCodes.length > 0 && (
                      <p><strong>CPT Codes:</strong> {bill.procedureCodes.join(', ')}</p>
                    )}
                    {bill.documentUrl && (
                      <a href={bill.documentUrl} target="_blank" rel="noopener noreferrer" className="view-document-btn">
                        View Bill
                      </a>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Evidence Documents Tab */}
        {activeTab === 'evidence' && (
          <div className="evidence-section">
            <h2>Evidence Documents</h2>
            {clientData.evidenceDocuments.documents.length === 0 ? (
              <p className="no-data">No evidence documents available</p>
            ) : (
              <div className="documents-list">
                {clientData.evidenceDocuments.documents.map(doc => (
                  <div key={doc._id} className="document-card">
                    <div className="document-header">
                      <h3>{doc.title}</h3>
                      <span className="evidence-type">{formatStageName(doc.evidenceType)}</span>
                    </div>
                    <p><strong>Description:</strong> {doc.description || 'No description provided'}</p>
                    {doc.dateOfIncident && (
                      <p><strong>Date of Incident:</strong> {new Date(doc.dateOfIncident).toLocaleDateString()}</p>
                    )}
                    {doc.location && (
                      <p><strong>Location:</strong> {doc.location}</p>
                    )}
                    {doc.tags && doc.tags.length > 0 && (
                      <div className="tags">
                        {doc.tags.map((tag, index) => (
                          <span key={index} className="tag">{tag}</span>
                        ))}
                      </div>
                    )}
                    {doc.documentUrl && (
                      <a href={doc.documentUrl} target="_blank" rel="noopener noreferrer" className="view-document-btn">
                        View Evidence
                      </a>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Litigation Stage Tab */}
        {activeTab === 'litigation' && (
          <div className="litigation-section">
            <h2>Litigation Stage Management</h2>
            
            <div className="current-stage-card">
              <h3>Current Stage</h3>
              <p className="stage-name">
                {clientData.litigationStage 
                  ? formatStageName(clientData.litigationStage.currentStage)
                  : 'Not Set'
                }
              </p>
              {clientData.litigationStage && clientData.litigationStage.lastUpdated && (
                <p className="last-updated">
                  Last Updated: {new Date(clientData.litigationStage.lastUpdated).toLocaleString()}
                </p>
              )}
            </div>

            <div className="stage-update-form">
              <h3>Update Litigation Stage</h3>
              
              <div className="form-group">
                <label>Select Stage:</label>
                <select 
                  value={stageUpdate.newStage}
                  onChange={(e) => setStageUpdate({...stageUpdate, newStage: e.target.value})}
                  className="form-control"
                >
                  <option value="">Select a stage...</option>
                  {litigationStages.map(stage => (
                    <option key={stage} value={stage}>
                      {formatStageName(stage)}
                    </option>
                  ))}
                </select>
              </div>

              <div className="form-group">
                <label>Notes:</label>
                <textarea
                  value={stageUpdate.notes}
                  onChange={(e) => setStageUpdate({...stageUpdate, notes: e.target.value})}
                  className="form-control"
                  rows="4"
                  placeholder="Add notes about this stage..."
                />
              </div>

              <div className="form-group">
                <label>Next Step Description:</label>
                <input
                  type="text"
                  value={stageUpdate.nextStepDescription}
                  onChange={(e) => setStageUpdate({...stageUpdate, nextStepDescription: e.target.value})}
                  className="form-control"
                  placeholder="Describe the next step..."
                />
              </div>

              <div className="form-group">
                <label>Next Step Due Date:</label>
                <input
                  type="date"
                  value={stageUpdate.nextStepDueDate}
                  onChange={(e) => setStageUpdate({...stageUpdate, nextStepDueDate: e.target.value})}
                  className="form-control"
                />
              </div>

              <div className="button-group">
                <button 
                  onClick={handleStageUpdate}
                  disabled={updatingStage}
                  className="btn btn-primary"
                >
                  {updatingStage ? 'Updating...' : 'Update Stage'}
                </button>
                <button 
                  onClick={handleCompleteStage}
                  className="btn btn-success"
                >
                  Complete Current Stage
                </button>
              </div>
            </div>

            {/* Stage History */}
            {clientData.litigationStage && clientData.litigationStage.stageHistory.length > 0 && (
              <div className="stage-history">
                <h3>Stage History</h3>
                <div className="history-timeline">
                  {clientData.litigationStage.stageHistory.map((stage, index) => (
                    <div key={index} className="history-item">
                      <div className="history-marker"></div>
                      <div className="history-content">
                        <h4>{formatStageName(stage.stage)}</h4>
                        <p className="history-date">
                          Completed: {new Date(stage.completedDate).toLocaleString()}
                        </p>
                        {stage.notes && <p className="history-notes">{stage.notes}</p>}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </div>

      <style jsx>{`
        .client-details-page {
          padding: 2rem;
          max-width: 1400px;
          margin: 0 auto;
        }
        .client-header {
          background: linear-gradient(135deg, #1E3A5F 0%, #0D1B2A 100%);
          color: white;
          padding: 2rem;
          border-radius: 12px;
          margin-bottom: 2rem;
        }
        .back-button {
          background: rgba(255, 255, 255, 0.2);
          border: none;
          color: white;
          padding: 0.5rem 1rem;
          border-radius: 6px;
          cursor: pointer;
          margin-bottom: 1rem;
        }
        .tabs {
          display: flex;
          gap: 0.5rem;
          margin-bottom: 2rem;
          border-bottom: 2px solid #e0e0e0;
        }
        .tabs button {
          padding: 1rem 1.5rem;
          background: none;
          border: none;
          border-bottom: 3px solid transparent;
          cursor: pointer;
          font-size: 1rem;
          transition: all 0.3s;
        }
        .tabs button.active {
          border-bottom-color: #DAA520;
          color: #DAA520;
          font-weight: 600;
        }
        .documents-list {
          display: grid;
          gap: 1.5rem;
        }
        .document-card {
          background: white;
          border: 1px solid #e0e0e0;
          border-radius: 12px;
          padding: 1.5rem;
        }
        .document-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 1rem;
        }
        .view-document-btn {
          display: inline-block;
          margin-top: 1rem;
          padding: 0.5rem 1rem;
          background: #1E3A5F;
          color: white;
          text-decoration: none;
          border-radius: 6px;
        }
        .billing-summary {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
          gap: 1rem;
          margin-bottom: 2rem;
        }
        .summary-card {
          background: white;
          border: 2px solid #e0e0e0;
          border-radius: 12px;
          padding: 1.5rem;
          text-align: center;
        }
        .amount {
          font-size: 2rem;
          color: #27AE60;
          font-weight: bold;
        }
        .amount.due {
          color: #E74C3C;
        }
        .current-stage-card {
          background: linear-gradient(135deg, #FFD700 0%, #DAA520 100%);
          color: #1E3A5F;
          padding: 2rem;
          border-radius: 12px;
          margin-bottom: 2rem;
        }
        .stage-name {
          font-size: 2rem;
          font-weight: bold;
          margin: 0.5rem 0;
        }
        .stage-update-form {
          background: white;
          border: 1px solid #e0e0e0;
          border-radius: 12px;
          padding: 2rem;
          margin-bottom: 2rem;
        }
        .form-group {
          margin-bottom: 1.5rem;
        }
        .form-group label {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 600;
          color: #333;
        }
        .form-control {
          width: 100%;
          padding: 0.75rem;
          border: 1px solid #ddd;
          border-radius: 6px;
          font-size: 1rem;
        }
        .button-group {
          display: flex;
          gap: 1rem;
        }
        .btn {
          padding: 0.75rem 1.5rem;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 600;
        }
        .btn-primary {
          background: #1E3A5F;
          color: white;
        }
        .btn-success {
          background: #27AE60;
          color: white;
        }
        .stage-history {
          background: white;
          border: 1px solid #e0e0e0;
          border-radius: 12px;
          padding: 2rem;
        }
        .history-timeline {
          position: relative;
          padding-left: 2rem;
        }
        .history-item {
          position: relative;
          margin-bottom: 2rem;
        }
        .history-marker {
          position: absolute;
          left: -2rem;
          top: 0.5rem;
          width: 12px;
          height: 12px;
          background: #DAA520;
          border-radius: 50%;
        }
        .tags {
          display: flex;
          gap: 0.5rem;
          flex-wrap: wrap;
          margin-top: 0.5rem;
        }
        .tag {
          background: #e0e0e0;
          padding: 0.25rem 0.75rem;
          border-radius: 12px;
          font-size: 0.85rem;
        }
      `}</style>
    </div>
  );
};

export default ClientDetailsPage;
```

### Client App - Connect to Law Firm
```javascript
// pages/client/connect-lawfirm.jsx
import React, { useState } from 'react';
import axios from 'axios';

const ConnectLawFirm = () => {
  const [firmCode, setFirmCode] = useState('');
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');
  const [connectedFirm, setConnectedFirm] = useState(null);

  const handleConnect = async (e) => {
    e.preventDefault();
    setLoading(true);
    setMessage('');

    try {
      const response = await axios.post(
        '/api/client/connect-lawfirm',
        { firmCode: firmCode.toUpperCase() },
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        }
      );
      
      setConnectedFirm(response.data.lawFirm);
      setMessage('Successfully connected to law firm!');
      setFirmCode('');
    } catch (error) {
      setMessage(error.response?.data?.message || 'Failed to connect to law firm');
    }
    
    setLoading(false);
  };

  return (
    <div className="connect-lawfirm-page">
      <div className="container">
        <h1>Connect to Your Law Firm</h1>
        <p className="subtitle">Enter your law firm's unique code to grant them access to your case documents</p>

        {!connectedFirm ? (
          <form onSubmit={handleConnect} className="connect-form">
            <div className="form-group">
              <label>Law Firm Code</label>
              <input
                type="text"
                value={firmCode}
                onChange={(e) => setFirmCode(e.target.value.toUpperCase())}
                placeholder="Enter firm code (e.g., ABC123)"
                className="form-input"
                required
                maxLength="10"
              />
              <p className="help-text">
                Your law firm will provide you with their unique code
              </p>
            </div>

            <button 
              type="submit" 
              className="connect-btn"
              disabled={loading || !firmCode}
            >
              {loading ? 'Connecting...' : 'Connect to Law Firm'}
            </button>
          </form>
        ) : (
          <div className="success-card">
            <div className="success-icon">✓</div>
            <h2>Connected Successfully!</h2>
            <p>You are now connected to:</p>
            <h3>{connectedFirm.name}</h3>
            <p className="firm-code">Firm Code: {connectedFirm.code}</p>
            <p className="info-text">
              Your law firm can now access your medical records, billing information, 
              evidence documents, and manage your litigation stages.
            </p>
          </div>
        )}

        {message && (
          <div className={`message ${connectedFirm ? 'success' : 'error'}`}>
            {message}
          </div>
        )}

        <div className="info-section">
          <h3>What Access Does Your Law Firm Have?</h3>
          <ul>
            <li>✓ View your medical records</li>
            <li>✓ Access medical billing documents</li>
            <li>✓ Review evidence documents</li>
            <li>✓ Update and track litigation stages</li>
          </ul>
          <p className="privacy-note">
            Your privacy is protected. You can revoke access at any time from your account settings.
          </p>
        </div>
      </div>

      <style jsx>{`
        .connect-lawfirm-page {
          min-height: 100vh;
          background: linear-gradient(135deg, #F5E6D3 0%, #FFF8E7 100%);
          padding: 2rem;
        }
        .container {
          max-width: 600px;
          margin: 0 auto;
        }
        h1 {
          color: #1E3A5F;
          text-align: center;
          margin-bottom: 0.5rem;
        }
        .subtitle {
          text-align: center;
          color: #666;
          margin-bottom: 2rem;
        }
        .connect-form {
          background: white;
          padding: 2rem;
          border-radius: 12px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .form-group {
          margin-bottom: 1.5rem;
        }
        .form-group label {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 600;
          color: #333;
        }
        .form-input {
          width: 100%;
          padding: 0.75rem 1rem;
          border: 2px solid #ddd;
          border-radius: 8px;
          font-size: 1.1rem;
          text-transform: uppercase;
          letter-spacing: 2px;
          text-align: center;
          font-weight: 600;
        }
        .help-text {
          margin-top: 0.5rem;
          font-size: 0.9rem;
          color: #666;
        }
        .connect-btn {
          width: 100%;
          padding: 1rem;
          background: linear-gradient(135deg, #FFD700 0%, #DAA520 100%);
          color: #1E3A5F;
          border: none;
          border-radius: 8px;
          font-size: 1.1rem;
          font-weight: 700;
          cursor: pointer;
          transition: transform 0.2s;
        }
        .connect-btn:hover:not(:disabled) {
          transform: translateY(-2px);
        }
        .connect-btn:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }
        .success-card {
          background: white;
          padding: 3rem 2rem;
          border-radius: 12px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.1);
          text-align: center;
        }
        .success-icon {
          width: 80px;
          height: 80px;
          background: #27AE60;
          color: white;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 3rem;
          margin: 0 auto 1rem;
        }
        .info-section {
          background: white;
          padding: 2rem;
          border-radius: 12px;
          margin-top: 2rem;
        }
        .info-section ul {
          list-style: none;
          padding: 0;
        }
        .info-section li {
          padding: 0.5rem 0;
          color: #27AE60;
          font-weight: 600;
        }
        .privacy-note {
          margin-top: 1rem;
          padding: 1rem;
          background: #FFF9E6;
          border-left: 4px solid #FFD700;
          font-size: 0.9rem;
        }
        .message {
          margin-top: 1rem;
          padding: 1rem;
          border-radius: 8px;
          text-align: center;
        }
        .message.success {
          background: #D4EDDA;
          color: #155724;
        }
        .message.error {
          background: #F8D7DA;
          color: #721C24;
        }
      `}</style>
    </div>
  );
};

export default ConnectLawFirm;
```

## Environment Variables (.env)
```
# Database
MONGODB_URI=mongodb://localhost:27017/verdictpath

# JWT
JWT_SECRET=your_super_secret_jwt_key_here_change_in_production
JWT_EXPIRE=7d

# Server
PORT=3000
NODE_ENV=development

# File Upload (AWS S3 or similar)
AWS_ACCESS_KEY_ID=your_aws_key
AWS_SECRET_ACCESS_KEY=your_aws_secret
AWS_BUCKET_NAME=verdictpath-documents
AWS_REGION=us-east-1

# Email (for notifications)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_password
```

## Installation Commands
```bash
# Initialize Node.js project
npm init -y

# Install dependencies
npm install express mongoose bcryptjs jsonwebtoken cors dotenv cookie-parser
npm install multer aws-sdk nodemailer express-validator

# Install dev dependencies
npm install --save-dev nodemon

# For frontend (Next.js)
npx create-next-app@latest verdictpath-frontend
cd verdictpath-frontend
npm install axios
```

## Key Features Implemented:

1. **Law Firm Portal Dashboard**
   - View all registered clients sorted by last name, first name
   - Search functionality for clients
   - Click to view client details

2. **Client Details View**
   - Medical records access
   - Medical billing with totals
   - Evidence documents
   - Litigation stage management

3. **Litigation Stage Management**
   - Update current stage
   - Complete stages
   - Track stage history
   - Add notes and next steps

4. **Client Connection System**
   - Clients input law firm code
   - Automatic connection and access granting
   - Privacy controls

5. **Security**
   - JWT authentication
   - Role-based access control
   - Document access verification
   - Secure file storage

This comprehensive system provides all the functionality you requested for the law firm portal!
